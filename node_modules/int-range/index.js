const $rangeList = Symbol('rangeList');
const $param2RnageList = Symbol('param2RnageList');

let poolSize = 50;
let objPool = [];

/**
 * 创建一个 Range 的实例
 * @param {number} min
 * @param {number} max
 * @returns {Range}
 */
let range = (min , max)=>{
    if(min>max){
        let t = min;
        min = max;
        max = t;
    }
    let r = Range.create();
    r.min = min;
    r.max = max;
    return r;
}

/**
 * 多个 Range 相加
 * 例如：
 * range(1,5) + range(3,7) = [range(1,7)]
 * range(1,2) + range(4,6) = [range(1,2), range(4,6)]
 * @param {Range} args
 * @returns {Array.<Range>}
 */
let rangeAdd = (...args)=>{
    let list = args;
    list.sort((a,b)=>{
        return a.min - b.min;
    })
    let numArr = [];
    list.map((range)=>{
        for (let i = range.min; i <= range.max ; i++) {
            if(numArr.indexOf(i)===-1){
                numArr.push(i);
            }
        }
    });
    return parseNumbers(numArr);
}

/**
 * range(1,5) - range(3,7) = [range(1,2)]
 * range(1,5) - range(3,7) - range(1,2) = []
 * @param {Range} args
 * @returns {Array.<Range>}
 */
let rangeSub = (...args)=>{
    if(args.length===0){
        return [];
    }
    let arr1 = args.shift().toArray();
    let list = args;
    while (list.length > 0){
        let rangeB = list.shift();
        let rangeBArr = rangeB.toArray();
        for (let i = 0; i < rangeBArr.length; i++) {
            let index = arr1.indexOf(rangeBArr[i]);
            if(index != -1){
                arr1.splice(index,1);
            }
        }
    }
    return parseNumbers(arr1);
}

/**
 * range(1,5) ∩ range(3,7) = [range(3,5)]
 * @param {Range} args
 * @returns {Array.<Range>}
 */
let rangeIntersect = (...args)=>{
    if(args.length===0){
        return [];
    }
    let arr1 = args.shift().toArray();
    let list = args;
    while (list.length > 0){
        let arr2 = list.shift().toArray();
        for (let i = arr1.length-1; i >= 0; i--) {
            let index = arr2.indexOf(arr1[i]);
            if(index == -1){
                arr1.splice(i,1);
            }
        }
    }
    return parseNumbers(arr1);
}

/**
 * range(1,5) cut range(3,7) = [range(1,2), range(3,5), range(6,7)]
 * @param {Range} args
 * @returns {Array.<Range>}
 */
let rangeCut = (...args)=>{
    let result = [];
    let laveList = args;
    while (laveList.length>0) {
        let curRange = laveList.shift().clone();
        let jiaoArr = [];   //保存所有交集
        for (let i = 0; i < result.length; i++) {
            let subRange = result[i];
            jiaoArr.push(...rangeIntersect(curRange, subRange));
        }
        let chaArr = rangeSub(curRange, ...jiaoArr);    //求差集

        //替换交集
        let tempResult = [];
        for (let i = 0; i < result.length; i++) {
            let subRange = result[i];
            let isFind = false;
            for (let j = 0; j < jiaoArr.length; j++) {
                let jiaoRange = jiaoArr[j];
                if(subRange.isIntersect(jiaoRange)){
                    isFind = true;
                    jiaoArr.splice(j,1);
                    tempResult.push(...rangeCut2(subRange, jiaoRange));
                    break;
                }
            }
            if(!isFind){
                tempResult.push(subRange);
            }
        }

        //添加差集
        tempResult.push(...chaArr);
        result = tempResult;
    }
    result.sort((a,b)=>{return a.min-b.min});
    return result;
}

let rangeCut2 = (range1, range2)=>{
    let result1 = rangeSub(range1,range2);
    let result2 = rangeSub(range2,range1);
    let result3 = rangeIntersect(range1, range2);
    let arr = [];
    if(result1.length>0){
        arr.push(...result1);
    }
    if(result2.length>0){
        arr.push(...result2);
    }
    if(result3.length>0){
        arr.push(...result3);
    }
    arr.sort((a,b)=>{return a.min-b.min});
    return arr;
}

let parseNumbers = (numbers)=>{
    let result = [];
    let range = null;
    for (let i = 0; i < numbers.length; i++) {
        let num = Number(numbers[i]);
        // 创建一个新Range
        if(range === null || range.max+1 != num){
            range = Range.create(num, 1);
            result.push(range);
        }
        else{
            range.max = num;
        }
    }
    return result;
}


const $begin = Symbol('begin');
const $length = Symbol('length');

class Range {
    /**
     *
     * @param {number} begin
     * @param {number} length
     */
    constructor(begin = 0, length = 1) {
        this.begin = begin;
        this.length = length;
    }

    /**
     * Range to Array
     * @returns {Array}
     */
    toArray() {
        let arr = [];
        for (let i = 0; i < this.length; i++) {
            arr.push(this.begin+i);
        }
        return arr;
    }

    clone() {
        return new Range(this.begin, this.length);
    }

    get begin() {
        return this[$begin];
    }

    set begin(value) {
        this[$begin] = Math.round(value);
        if(isNaN(this[$begin])){
            this[$length] = 0;
        }
    }

    get length() {
        return this[$length];
    }

    set length(value) {
        value = Number(value);
        if(isNaN(value)){
            this[$length] = 0;
        }else{
            this[$length] = Math.max(0, Math.round(value));

        }
    }

    get min() {
        return this.begin;
    }

    set min(value) {
        let _max = this.max;
        this.begin = value;
        this.length = _max - value + 1;
    }

    get max() {
        if(this.length===0){
            return this.begin;
        }
        return this.begin + this.length - 1;
    }

    set max(value) {
        this.length = Math.max(0, value - this.min + 1);
    }

    /**
     * 判断对象是否包含 range
     * @param range
     * @returns {boolean}
     */
    isContains(range) {
        return this.min <= range.min && this.max >= range.max;
    }

    /**
     * 判断对象是否与 range 相交
     * @param range
     * @returns {boolean}
     */
    isIntersect(range) {
        return (this.min <= range.max && this.min >= range.min)
            || (this.max >= range.min && this.max <= range.max)
            || (this.min <= range.min && this.max >= range.max)
            || (this.min >= range.min && this.max <= range.max);
    }

    /**
     *
     * @param value
     * @returns {boolean}
     */
    has(value) {
        return value >= this.min && value <= this.max;
    }

    /**
     *
     * @param range
     * @returns {boolean}
     */
    equal(range) {
        return this.begin===range.begin && this.length===range.length;
    }

    toString() {
        return `{min:${this.min}, max:${this.max}, length:${this.length}}`
    }

    static create(begin=0, length=1) {
        if(objPool.length>0){
            const range = objPool.pop();
            range.begin = begin;
            range.length = length;
            return range;
        }
        return new Range(begin, length);
    }

    static release(range){
        if(range instanceof Range){

            range.begin = 0;
            range.length = 0;

            if(objPool.length+1 <= poolSize){
                objPool.push(range);
            }
        }
    }
}


module.exports = {Range, range, rangeAdd, rangeSub, rangeIntersect, rangeCut};