const $rangeList = Symbol('rangeList');
const $param2RnageList = Symbol('param2RnageList');

let poolSize = 50;
let objPool = [];

/**
 * 创建一个 Range 的实例
 * @param {number} min
 * @param {number} max
 * @returns {Range}
 */
let range = (min , max=undefined)=>{
    if(max === undefined){
        return Range.create(min, 0);
    }

    if(min>max){
        let t = min;
        min = max;
        max = t;
    }
    let r = Range.create(min, max-min+1);
    return r;
}

/**
 * 多个 Range 相加
 * 例如：
 * range(1,5) + range(3,7) = [range(1,7)]
 * range(1,2) + range(4,6) = [range(1,2), range(4,6)]
 * @param {Range} args
 * @returns {Array.<Range>}
 */
let rangeAdd = (...args)=>{
    const result = [];
    args.sort((a,b)=>{
        return a.min - b.min;
    })
    while (args.length>0){
        const curRange = args.shift().clone();
        const removeIdxs = [];
        for (let i = 0; i<result.length; i++) {
            let range = result[i];
            if(curRange.isIntersect(range)){
                removeIdxs.push(i);
                curRange.min = Math.min(curRange.min, range.min);
                curRange.max = Math.max(curRange.max, range.max);
            }
        }

        for (let i = removeIdxs.length-1; i >= 0 ; i--) {
            let obsolete = result.splice(removeIdxs[i], 1)[0];
            Range.release(obsolete);
        }

        result.push(curRange);
    }
    return result;
}

/**
 * range(1,5) - range(3,7) = [range(1,2)]
 * range(1,5) - range(3,7) - range(1,2) = []
 * @param {Range} args
 * @returns {Array.<Range>}
 */
let rangeSub = (...args)=>{
    if(args.length===0){
        return [];
    }
    let rawList = [args.shift().toRaw()];
    args.sort((a,b)=>{
        return a.begin - b.begin;
    })
    while (args.length>0){
        let arg = args.shift().toRaw();
        for (let i = 0; i < rawList.length; i++) {
            const raw = rawList[i];
            if((typeof raw) === 'number' && (typeof arg) === 'number'){
                if(raw === arg){
                    return [];
                }
            }
            else if((typeof raw) === 'number' && arg instanceof Array){
                if(arg.indexOf(raw) != -1){
                    return [];
                }
            }
            else if(raw instanceof Array && (typeof arg) === 'number'){
                const idx = raw.indexOf(arg);
                if(idx != -1 && idx != 0){
                    const rightArr = raw.slice(idx);
                    rawList[i] = raw.slice(0, idx);
                    rawList.splice(i+1, 0, rightArr);
                    break;
                }
            }
            else if(raw instanceof Array && arg instanceof Array){
                // 找相同的最小值
                const r1Min = raw[0];
                const r1Max = raw[raw.length-1];
                const r2Min = arg[0];
                const r2Max = arg[arg.length-1];
                let min = null;
                if (r1Min < r2Min) {
                    if (r1Max >= r2Min) {
                        min = r2Min;
                    }
                } else if (r1Min >= r2Min && r1Min <= r2Max) {
                    min = Math.max(r1Min, r2Min);
                }
                if(min === null){
                    continue;
                }

                const idx = raw.indexOf(min);
                const idx2 = arg.indexOf(min);
                arg = arg.slice(idx2);

                const delLen = Math.min(raw.length-idx, arg.length);
                if(idx+delLen < raw.length && idx != 0){  //切割情况
                    const rightArr = raw.slice(idx+delLen);
                    rawList[i] = raw.slice(0, idx);
                    rawList.splice(i+1, 0, rightArr);
                    break;
                }
                else{
                    raw.splice(idx, delLen);
                    arg.splice(0, delLen);
                    if(arg.length===0){
                        break;
                    }
                }
            }
        }
    }

    // 剔除空数组
    rawList = rawList.filter((value)=>{
        if( (value instanceof Array) && value.length>0){
            return value;
        }
        else if(typeof value === 'number'){
            return value;
        }
        else{
            return null;
        }
    })

    // 解析 raw
    const result = [];
    for (let i = 0; i < rawList.length; i++) {
        const item = rawList[i];
        if(item instanceof Array){
            result.push(Range.create(item[0], item.length));
        }
        else if(typeof item === 'number'){
            result.push(Range.create(item, 0));
        }
    }

    return result;
}

/**
 * range(1,5) ∩ range(3,7) = [range(3,5)]
 * @param {Range} args
 * @returns {Array.<Range>}
 */
let rangeIntersect = (...args)=> {
    if (args.length === 0) {
        return [];
    }
    const r1 = args.shift().clone();
    while (args.length > 0) {
        const r2 = args.shift();
        if (r1.length === 0 && r2.length !== 0) {
            if (r1.begin < r2.min || r1.begin > r2.max) {
                return [];
            }
        } else if (r1.length !== 0 && r2.length === 0) {
            if (r2.begin >= r1.min && r2.begin <= r1.max) {
                r1.begin = r2.begin;
                r1.length = 0;
            } else {
                return [];
            }
        } else if (r1.length === 0 && r2.length === 0) {
            if (r1.begin !== r2.begin) {
                return [];
            }
        } else {
            if (r1.min < r2.min) {
                if (r1.max < r2.min) {
                    return [];
                } else {
                    r1.min = r2.min;
                    r1.max = Math.min(r1.max, r2.max);
                }
            } else if (r1.min >= r2.min && r1.min <= r2.max) {
                r1.min = Math.max(r1.min, r2.min);
                r1.max = Math.min(r1.max, r2.max);
            } else {
                return [];
            }
        }
    }
    return [r1];
}

/**
 * range(1,5) cut range(3,7) = [range(1,2), range(3,5), range(6,7)]
 * @param {Range} args
 * @returns {Array.<Range>}
 */
let rangeCut = (...args)=>{
    let result = [];
    let laveList = args;
    while (laveList.length>0) {
        let curRange = laveList.shift().clone();
        let jiaoArr = [];   //保存所有交集
        for (let i = 0; i < result.length; i++) {
            let subRange = result[i];
            jiaoArr.push(...rangeIntersect(curRange, subRange));
        }
        let chaArr = rangeSub(curRange, ...jiaoArr);    //求差集

        //替换交集
        let tempResult = [];
        for (let i = 0; i < result.length; i++) {
            let subRange = result[i];
            let isFind = false;
            for (let j = 0; j < jiaoArr.length; j++) {
                let jiaoRange = jiaoArr[j];
                if(subRange.isIntersect(jiaoRange)){
                    isFind = true;
                    jiaoArr.splice(j,1);
                    tempResult.push(...rangeCut2(subRange, jiaoRange));
                    break;
                }
            }
            if(!isFind){
                tempResult.push(subRange);
            }
        }

        //添加差集
        tempResult.push(...chaArr);
        result = tempResult;
    }
    result.sort((a,b)=>{return a.min-b.min});
    return result;
}

let rangeCut2 = (range1, range2)=>{
    let result1 = rangeSub(range1,range2);
    let result2 = rangeSub(range2,range1);
    let result3 = rangeIntersect(range1, range2);
    let arr = [];
    if(result1.length>0){
        arr.push(...result1);
    }
    if(result2.length>0){
        arr.push(...result2);
    }
    if(result3.length>0){
        arr.push(...result3);
    }
    arr.sort((a,b)=>{return a.min-b.min});
    return arr;
}


const $begin = Symbol('begin');
const $length = Symbol('length');

class Range {
    /**
     *
     * @param {number} begin
     * @param {number} length
     */
    constructor(begin = 0, length = 1) {
        this.begin = begin;
        this.length = length;
    }

    /**
     * Range to Array
     * @returns {Array}
     */
    toArray() {
        let arr = [];
        for (let i = 0; i < this.length; i++) {
            arr.push(this.begin+i);
        }
        return arr;
    }

    /**
     * 
     * @returns {Array | number}
     */
    toRaw() {
        if(this.length>0){
            return this.toArray();
        }
        return this.begin;
    }

    clone() {
        return new Range(this.begin, this.length);
    }

    get begin() {
        return this[$begin];
    }

    set begin(value) {
        this[$begin] = Math.round(value);
        if(isNaN(this[$begin])){
            this[$length] = 0;
        }
    }

    get length() {
        return this[$length];
    }

    set length(value) {
        value = Number(value);
        if(isNaN(value)){
            this[$length] = 0;
        }else{
            this[$length] = Math.max(0, Math.round(value));

        }
    }

    get min() {
        return this.begin;
    }

    set min(value) {
        let _max = this.max;
        this.begin = value;
        this.length = _max - value + 1;
    }

    get max() {
        if(this.length===0){
            return this.begin;
        }
        return this.begin + this.length - 1;
    }

    set max(value) {
        this.length = Math.max(0, value - this.min + 1);
    }

    /**
     * 判断对象是否包含 range
     * @param range
     * @returns {boolean}
     */
    isContains(range) {
        return this.min <= range.min && this.max >= range.max && this.length >= range.length;
    }

    /**
     * 判断对象是否与 range 相交
     * @param range
     * @returns {boolean}
     */
    isIntersect(range) {
        return (this.min >= range.min && this.min <= range.max)
            || (this.max >= range.min && this.max <= range.max)
            || (range.min >= this.min && range.min <= this.max)
            || (range.max >= this.min && range.max <= this.max);
    }

    /**
     *
     * @param value
     * @returns {boolean}
     */
    has(value) {
        return value >= this.min && value <= this.max;
    }

    /**
     *
     * @param range
     * @returns {boolean}
     */
    equal(range) {
        return this.begin===range.begin && this.length===range.length;
    }

    toString() {
        return `{min:${this.min}, max:${this.max}, length:${this.length}}`
    }

    static create(begin=0, length=1) {
        if(objPool.length>0){
            const range = objPool.pop();
            range.begin = begin;
            range.length = length;
            return range;
        }
        return new Range(begin, length);
    }

    static release(range){
        if(range instanceof Range){

            range.begin = 0;
            range.length = 0;

            if(objPool.length+1 <= poolSize){
                objPool.push(range);
            }
        }
    }
}


module.exports = {Range, range, rangeAdd, rangeSub, rangeIntersect, rangeCut};